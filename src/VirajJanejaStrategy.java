//	Essentially, the strategy shoots at a preordained pattern before shifting its focus
//should it land a hit. The strategy initially shoots in a slash pattern, (which in my
//experience is reliable enough to almost always yield 1 boat), and when a boat is hit,
//it shoots around the boat in an attempt to locate the remnant of said boat. The shots
//would be up, left, down, and right of the boat, and would act in the same pattern
//should any of those shots also yield a boat. If somehow in a miracle no boat is hit in 
//the first volley, a second slash would be made perpendicular to the first, and then if
//once again nothing was found, it would shoot in 2 more lines, each passing through the
//center before finally turning to random shots. It is worth noting that the strategy was 
//built in a fashion that duplicate shots are impossible.
//	This is done via two primary methods: the shootingPlan and hitPos method. The
//shootingPlan has an integrated plan for which targets to hit, and will go through them
//while validating they are indeed unique shots. The second method, hitPos, uses an arraylist
//called the shootAroundQueue that has a collection of all marked points. Marked points
//are points generated by hitPos that are above, below, to the left, and to the right of the
//shot ship, and are added per ship that is shot. Once the queue is exhausted, the shootingPlan
//resumes. Eventually all the boats will be caught, and thus the game would end. I definitely
//feel that more optimization for the hitPos method and where it shoots could be beneficial,
//but my tampering was in another area, which eventually led to me not having enough time
//to successfully finish the new hitPos method (although it is worth noting it had considerable work).


import java.util.ArrayList;

public class VirajJanejaStrategy extends ComputerBattleshipPlayer{
	ArrayList<Position> alreadyShot;
	ArrayList<Position> shootAroundQueue;

	public String playerName() {
		return "Viraj Janeja's Strategy";
	}
	
	public String author() {
		return "Viraj Janeja";
	}
	
	
	public Position shoot() {
		Position result = new Position((int)(Math.random()*10), (int)(Math.random()*10));
		if(prevShot() == 1) {
			hitPos(getPrevShot());
		}
		if(shootAroundQueue.size()>0) {
			do {
				if(checkPosUsed(shootAroundQueue.get(0))) {
					shootAroundQueue.remove(0);
				}
				else {
					result = shootAroundQueue.remove(0);
				}
			} while (checkPosUsed(result) && shootAroundQueue.size()>0);
		}else 
			result = ShootingPlan();
		alreadyShot.add(result);
		return result;
	}
	
	private Position ShootingPlan() {
		Position shootAt;
		for(int i = 0; i<10;i++) {
			shootAt = new Position(i, i);
			if(!checkPosUsed(shootAt))
					return shootAt;
		}
		for(int j = 0, i = 9; j<10;j++, i--) {
			shootAt = new Position(i, j);
			if(!checkPosUsed(shootAt))
					return shootAt;
		}
		
		for(int j = 0; j<10;j++) {
			shootAt = new Position(4, j);
			if(!checkPosUsed(shootAt))
					return shootAt;
		}
		
		for(int j = 0; j<10;j++) {
			shootAt = new Position(j, 4);
			if(!checkPosUsed(shootAt))
					return shootAt;
		}
		
		do {
			shootAt = new Position((int)(Math.random()*10), (int)(Math.random()*10));
		} while (checkPosUsed(shootAt));
		return shootAt;
	}
	
	private void hitPos(Position pos) {
		if(pos.rowIndex()>0)
			shootAroundQueue.add(new Position(pos.rowIndex()-1, pos.columnIndex()));
		if(pos.rowIndex()<9)
			shootAroundQueue.add(new Position(pos.rowIndex()+1, pos.columnIndex()));
		if(pos.columnIndex()>0)
			shootAroundQueue.add(new Position(pos.rowIndex(), pos.columnIndex()-1));
		if(pos.columnIndex()<9)
			shootAroundQueue.add(new Position(pos.rowIndex(), pos.columnIndex()+1));
	}
		
	private int prevShot() {
		if(alreadyShot.size()>0) {
			if(this.getGrid().hit(getPrevShot()))
				return 1;
		}
		return 0;
	}
	
	private Position getPrevShot() {
		return alreadyShot.get(alreadyShot.size()-1);
	}

	private boolean checkPosUsed(Position pos) {
		for(Position item: alreadyShot) {
			if(pos.rowIndex()==item.rowIndex() && pos.columnIndex()==item.columnIndex()) {
				return true;
			}
		}
		return false;
	}
	
	public void startGame() {
		super.initializeGrid();
		alreadyShot = new ArrayList<Position>();
		shootAroundQueue = new ArrayList<Position>();
	}
	
	
}
